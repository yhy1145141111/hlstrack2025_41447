# 嵌赛FPGA赛道-AMD 命题式基础赛道 - 初赛

# Vitis Library HLS算法优化竞赛评分规则手册

## 1. 竞赛概述

本次竞赛要求学生对 Vitis Libraries 中的三个 L1 算法进行 HLS 优化，目标是在保持功能正确性的前提下，最小化算法的执行延迟（Latency）。

### 1.1 竞赛题目

| 题目编号        | 算法名称                       | 测试路径                                          |
| --------------- | ------------------------------ | ------------------------------------------------- |
| **题目1** | SHA-256                        | `security/L1/tests/sha224_256/sha256/`          |
| **题目2** | LZ4 Compress                   | `data_compression/L1/tests/lz4_compress/`       |
| **题目3** | Cholesky (Complex Fixed-Point) | `solver/L1/tests/cholesky/complex_fixed_arch0/` |

### 1.2 目标平台

- **FPGA 器件**：Zynq-7000 (xc7z020-clg484-1)
- **工具版本**：Vitis HLS 2024.2

### 1.3 提交要求

* 开源仓库和代码参考每个测试路径下的submission guide
* 竞赛无需提交视频，但是需要提交仓库压缩包以及项目报告

---

## 2. 优化约束条件

### 2.1 必须遵守的规则

1. **时钟频率约束**：允许修改工程时钟频率

   - **时钟不确定性（Clock Uncertainty）**：每个题目已设置为目标时钟周期的 **10%**，此参数不可修改
   - **Slack 计算公式**（Vitis HLS 内部计算）：

     ```
     Slack = (Target Clock Period - Clock Uncertainty) - Estimated Clock Period
     ```

     其中：`Clock Uncertainty = Target Clock Period × 10%`
   - **时序违例处理**：

     - 若 Slack ≤ 0（时序违例），仍可参与评分，但**该题总分扣除 10 分**
     - 建议：在追求极致性能的同时，关注时序安全性
     - 时序违例的设计在实际硬件上可能无法稳定工作
   - **评分方式**：按照 `Estimated Clock Period × Cosim Latency` 计算执行时间
   - 允许修改 Tcl 脚本或 Makefile 中的时钟配置（如 `create_clock -period <value>`）
2. **功能正确性**：优化后的算法必须通过 Co-simulation 验证

   - C Simulation (csim) 必须 PASS
   - Co-simulation (cosim) 必须 PASS
   - 输出结果与参考实现完全一致
3. **允许修改的文件**：

   - ✅ 允许修改指定的头文件（`*.hpp`）- 参考submission guide
   - ✅ 允许修改 Makefile 或 Tcl 脚本中的时钟配置
   - ❌ 不得修改测试文件 (`test_*.cpp`)
   - ❌ 不得修改算法功能逻辑（输出必须与原始实现一致）
4. **资源约束**：优化后的设计必须能在 xc7z020 器件上实现

   - LUT、FF、BRAM、DSP 使用量不得超过器件容量
   - 资源超限的设计视为不合格，该题得 0 分

---

## 3. 评分公式

### 3.1 单题评分标准

每道题目的得分基于 **实际执行时间**（Execution Time）计算，综合考虑时钟周期数和时钟频率。

#### 3.1.1 执行时间计算

对于每道题目，定义核心评测指标：

**执行时间（Execution Time，单位：纳秒 ns）**：

```
T_exec = Estimated_Clock_Period × Cosim_Latency
```

其中：

- **Estimated_Clock_Period**：综合报告中的估计时钟周期（单位：ns）
  - 从 C Synthesis 报告的 `Timing Summary` 中提取
  - 无论是否满足时序要求，均使用此值计算执行时间
- **Cosim_Latency**：Co-simulation 报告中的 Latency（max，单位：时钟周期数）

**时序验证**：

根据 Vitis HLS 工具的 Slack 计算公式：

```
Slack = (Target Clock Period - Clock Uncertainty) - Estimated Clock Period
其中：Clock Uncertainty = Target Clock Period × 10%
```

示例：

- 若 Target = 10 ns，则 Clock Uncertainty = 1 ns
- 若 Estimated = 9.5 ns，则 Slack = (10 - 1) - 9.5 = -0.5 ns（时序违例）
- 若 Estimated = 8.5 ns，则 Slack = (10 - 1) - 8.5 = +0.5 ns（时序满足）

#### 3.1.2 归一化得分

对于每道题目：

- **T_baseline**：官方未优化版本的执行时间（基准值）
- **T_student**：学生优化版本的执行时间
- **T_best**：所有提交中的最优执行时间

计算**归一化得分**：

```
Score_normalized = (T_baseline - T_student) / (T_baseline - T_best)
```

#### 3.1.3 单题得分公式

每道题目满分 **100 分**，按以下规则计分：

```
Score_base = 100 × Score_normalized
```

**时序违例扣分**：

```
若 Slack ≤ 0（时序违例）：
    Score_single = Score_base - 10
否则：
    Score_single = Score_base
```

**特殊情况处理**：

1. **未通过验证**（得 0 分）：

   - 若 C Simulation 未通过 → 0 分
   - 若 Co-simulation 未通过 → 0 分
   - 若输出结果错误 → 0 分
   - 若资源超限 → 0 分
2. **时序违例扣分**：

   - 若 Slack ≤ 0（时序违例），先按执行时间计算得分，**然后扣除 10 分**
   - Slack 计算公式：`Slack = (Target - Target×10%) - Estimated`
   - 注意：时序违例的设计在实际硬件上可能无法稳定工作
   - 建议在报告中说明时序违例的原因和风险
3. **无优化或负优化**：

   - 若 T_student ≥ T_baseline → 基础分 10 分（功能正确但无优化）
   - 若 T_student > T_baseline（性能退化）→ 5 分
   - 以上情况若时序违例，扣分后可能为 0 分或负分（按 0 分计）
4. **最优提交**：

   - 若 T_student = T_best 且无时序违例 → 满分 100 分
   - 若 T_student = T_best 但时序违例 → 90 分（100 - 10）
5. **得分上限**：

   - 单题得分不超过 100 分，不低于 0 分（负分按 0 分计）

---

### 3.2 总分计算

#### 3.2.1 加权总分

三道题目采用**加权平均**方式计算总分：

```
Total_Score = w1 × Score_SHA256 + w2 × Score_LZ4 + w3 × Score_QRD
```

**推荐权重分配**（根据算法难度）：

| 算法             | 权重 | 理由                                       |
| ---------------- | ---- | ------------------------------------------ |
| SHA-256          | 30%  | 基础哈希算法，适合入门优化                 |
| LZ4 Compress     | 35%  | 中等难度，涉及数据依赖和流水线             |
| Cholesky (ARCH0) | 35%  | 较高难度，涉及定点运算、复数运算和矩阵分解 |

即：

```
Total_Score = 0.30 × Score_SHA256 + 0.35 × Score_LZ4 + 0.35 × Score_Cholesky
```

#### 3.2.2 完整性加分

为鼓励学生完成所有题目，设置**完整性加分**：

- 完成 1 道题目：总分 × 1.0（无加分）
- 完成 2 道题目：总分 × 1.05（加 5%）
- 完成 3 道题目：总分 × 1.10（加 10%）

最终得分：

```
Final_Score = Total_Score × Completeness_Bonus
```

**注意**：最终得分上限为 110 分。

---

## 4. 评分流程

### 4.1 自动化评分脚本

评审系统将执行以下步骤：

#### 步骤 1：环境准备

```bash
source /opt/xilinx/Vitis_HLS/2024.2/settings64.sh
export XPART=xc7z020-clg484-1
```

#### 步骤 2：运行每道题目

以 SHA-256 为例：

```bash
cd Vitis_Libraries/security/L1/tests/sha224_256/sha256
make clean
make run TARGET=csim    # 验证功能
make run TARGET=cosim   # 获取 Latency
```

Cholesky 测试：

```bash
cd Vitis_Libraries/solver/L1/tests/cholesky/complex_fixed_arch0
make clean
make run TARGET=csim
make run TARGET=cosim
```

#### 步骤 3：提取关键指标

**3.1 提取时钟周期（Clock Period）**

从 C Synthesis 报告中提取：

```
proj_*/solution1/syn/report/*_csynth.rpt
```

关键字段（Timing Summary 部分）：

- **Target Clock Period**：目标时钟周期（ns）
- **Estimated Clock Period**：估计时钟周期（ns）
- **Uncertainty**：时钟不确定性（固定为 Target 的 10%，不可修改）

**3.2 计算 Slack**

根据 Vitis HLS 工具内部公式：

```
Slack = (Target Clock Period - Clock Uncertainty) - Estimated Clock Period
其中：Clock Uncertainty = Target Clock Period × 10%

简化公式：
Slack = Target × 0.9 - Estimated
```

示例计算：

```
情况1：Target = 10 ns, Estimated = 8.5 ns
  Slack = 10 × 0.9 - 8.5 = 9.0 - 8.5 = +0.5 ns ✅ 时序满足

情况2：Target = 10 ns, Estimated = 9.5 ns
  Slack = 10 × 0.9 - 9.5 = 9.0 - 9.5 = -0.5 ns ⚠️ 时序违例（扣10分）

情况3：Target = 8 ns, Estimated = 7.0 ns
  Slack = 8 × 0.9 - 7.0 = 7.2 - 7.0 = +0.2 ns ✅ 时序满足
```

**3.3 提取 Co-simulation Latency**

从 Co-simulation 报告中提取：

```
proj_*/solution1/sim/report/*_cosim.rpt
```

关键字段：

- **Latency (cycles) - max**：最大延迟（时钟周期数）

**3.3 计算执行时间**

```
Execution_Time = Estimated_Clock_Period × Cosim_Latency_max
```

**3.4 判断时序违例并扣分**

根据 Vitis HLS 工具内部公式计算 Slack：

```
Slack = (Target_Clock_Period × 0.9) - Estimated_Clock_Period
```

判断规则：

```
如果 Slack ≤ 0：
    时序违例 = True
    该题得分需扣除 10 分
否则：
    时序违例 = False
    正常计分
```

**注意**：

- Clock Uncertainty 固定为 Target 的 10%，不可修改
- 时序违例的设计在实际硬件上可能无法稳定工作
- 建议在报告中说明时序状态

#### 步骤 4：计算得分

根据第 3 节公式计算各题得分和总分。

---

### 4.2 排名规则

1. **主排名**：按 `Final_Score` 从高到低排序
2. **平局处理**（若总分相同）：
   - 优先比较 Cholesky 得分（难度最高）
   - 其次比较 LZ4 Compress 得分
   - 最后比较 SHA-256 得分

---

## 5. 评分示例

### 5.1 示例数据

假设三道题目的 Baseline 和参赛者数据如下：

#### SHA-256 示例

| 提交者   | 目标时钟 (ns) | 估计时钟 (ns) | Slack 计算     | Slack 值       | Cosim Latency | 执行时间 (ns) | 时序状态        |
| -------- | ------------- | ------------- | -------------- | -------------- | ------------- | ------------- | --------------- |
| Baseline | 10.0          | 9.5           | 10×0.9 - 9.5  | **-0.5** | 1000          | 9,500         | ⚠️ 违例 -10分 |
| 学生A    | 8.0           | 7.0           | 8×0.9 - 7.0   | **+0.2** | 850           | 5,950         | ✅ 安全         |
| 学生B    | 5.0           | 4.8           | 5×0.9 - 4.8   | **-0.3** | 650           | 3,120         | ⚠️ 违例 -10分 |
| 学生C    | 12.0          | 10.5          | 12×0.9 - 10.5 | **+0.3** | 500           | 5,250         | ✅ 安全         |

**说明**：

- Baseline 时序违例（Slack = -0.5），需扣 10 分
- 学生 B 时序违例（Slack = -0.3），虽然执行时间最短，但需扣 10 分

#### LZ4 Compress 示例

| 提交者   | 目标时钟 (ns) | 估计时钟 (ns) | Slack 计算    | Slack 值       | Cosim Latency | 执行时间 (ns) | 时序状态        |
| -------- | ------------- | ------------- | ------------- | -------------- | ------------- | ------------- | --------------- |
| Baseline | 10.0          | 9.5           | 10×0.9 - 9.5 | **-0.5** | 5000          | 47,500        | ⚠️ 违例 -10分 |
| 学生A    | 8.0           | 7.0           | 8×0.9 - 7.0  | **+0.2** | 4000          | 28,000        | ✅ 安全         |
| 学生B    | 10.0          | 8.5           | 10×0.9 - 8.5 | **+0.5** | 3500          | 29,750        | ✅ 安全         |
| 学生C    | 6.0           | 5.3           | 6×0.9 - 5.3  | **+0.1** | 5000          | 26,500        | ✅ 安全（最优） |

### 5.2 学生 A 得分计算

#### SHA-256

```
T_baseline = 9,500 ns
T_student_A = 5,950 ns
T_best = 3,120 ns （学生B，虽然时序违例）

Score_normalized = (9500 - 5950) / (9500 - 3120) = 3550 / 6380 = 0.556
Score_base = 100 × 0.556 = 55.6 分

检查时序：
Slack_A = 8 × 0.9 - 7.0 = 7.2 - 7.0 = +0.2 ns ✅ 时序满足

最终得分：
Score_SHA256 = 55.6 分（无扣分）
```

**说明**：学生 A 时序安全，但得分被激进的学生 B 拉低。

#### LZ4 Compress

```
T_baseline = 47,500 ns
T_student_A = 28,000 ns
T_best = 26,500 ns （学生C）

Score_normalized = (47500 - 28000) / (47500 - 26500) = 19500 / 21000 = 0.929
Score_base = 100 × 0.929 = 92.9 分

检查时序：
Slack_A = 8 × 0.9 - 7.0 = 7.2 - 7.0 = +0.2 ns ✅ 时序满足

最终得分：
Score_LZ4 = 92.9 分（无扣分）
```

#### Cholesky（假设）

```
假设学生 A 该题得分：70.0 分
```

#### 加权总分

```
Total_Score = 0.30 × 55.6 + 0.35 × 92.9 + 0.35 × 70.0
            = 16.68 + 32.52 + 24.50
            = 73.70 分
```

#### 完整性加分（完成 3 题）

```
Final_Score = 73.70 × 1.10 = 81.07 分
```

---

### 5.3 学生 B 得分计算

#### SHA-256

```
T_baseline = 9,500 ns
T_student_B = 3,120 ns
T_best = 3,120 ns （学生 B 自己）

Score_normalized = (9500 - 3120) / (9500 - 3120) = 6380 / 6380 = 1.0
Score_base = 100 × 1.0 = 100 分

检查时序：
Slack_B = 5 × 0.9 - 4.8 = 4.5 - 4.8 = -0.3 ns ⚠️ 时序违例

最终得分：
Score_SHA256 = 100 - 10 = 90 分（扣除时序违例10分）
```

**说明**：学生 B 采用激进高频策略，执行时间最短获得基础满分，但因时序违例扣 10 分。
**风险提示**：该设计在实际硬件上可能无法稳定工作在目标频率。

#### LZ4 Compress

```
T_baseline = 47,500 ns
T_student_B = 29,750 ns
T_best = 26,500 ns

Score_normalized = (47500 - 29750) / (47500 - 26500) = 17750 / 21000 = 0.845
Score_base = 100 × 0.845 = 84.5 分

检查时序：
Slack_B = 10 × 0.9 - 8.5 = 9.0 - 8.5 = +0.5 ns ✅ 时序满足

最终得分：
Score_LZ4 = 84.5 分（无扣分）
```

**说明**：学生 B 在 LZ4 上采用保守策略，时序安全。

#### Cholesky（假设）

```
假设学生 B 该题得分：75.0 分（时序满足）
```

#### 加权总分

```
Total_Score = 0.30 × 90 + 0.35 × 84.5 + 0.35 × 75.0
            = 27.00 + 29.58 + 26.25
            = 82.83 分
```

#### 完整性加分（完成 3 题）

```
Final_Score = 82.83 × 1.10 = 91.11 分
```

**注意**：学生 B 在 SHA-256 上虽然时序违例，但因执行时间最优，扣分后仍得 90 分。

---

### 5.4 学生 C 得分计算

#### SHA-256

```
T_baseline = 9,500 ns
T_student_C = 5,250 ns
T_best = 3,120 ns

Score_normalized = (9500 - 5250) / (9500 - 3120) = 4250 / 6380 = 0.666
Score_base = 100 × 0.666 = 66.6 分

检查时序：
Slack_C = 12 × 0.9 - 10.5 = 10.8 - 10.5 = +0.3 ns ✅ 时序满足

最终得分：
Score_SHA256 = 66.6 分（无扣分）
```

**说明**：学生 C 选择保守的低频策略，通过优化 Latency 获得不错成绩，且时序安全。

#### LZ4 Compress

```
T_baseline = 47,500 ns
T_student_C = 26,500 ns
T_best = 26,500 ns （学生 C 自己）

Score_normalized = (47500 - 26500) / (47500 - 26500) = 21000 / 21000 = 1.0
Score_base = 100 × 1.0 = 100 分

检查时序：
Slack_C = 6 × 0.9 - 5.3 = 5.4 - 5.3 = +0.1 ns ✅ 时序满足

最终得分：
Score_LZ4 = 100 分（满分，无扣分）
```

**说明**：学生 C 采用高频策略且时序满足，获得满分。

#### Cholesky（假设）

```
假设学生 C 该题得分：85.0 分
```

#### 加权总分

```
Total_Score = 0.30 × 66.6 + 0.35 × 100 + 0.35 × 85.0
            = 19.98 + 35.00 + 29.75
            = 84.73 分
```

#### 完整性加分（完成 3 题）

```
Final_Score = 84.73 × 1.10 = 93.20 分
```

---

### 5.5 最终排名

| 排名              | 学生   | 最终得分           | 策略特点          | 时序状态                |
| ----------------- | ------ | ------------------ | ----------------- | ----------------------- |
| 🥇**第1名** | 学生 C | **93.20 分** | 平衡优化，LZ4满分 | 全部时序安全 ✅         |
| 🥈**第2名** | 学生 B | **91.11 分** | SHA-256激进策略   | SHA-256 违例扣10分 ⚠️ |
| 🥉**第3名** | 学生 A | **81.07 分** | 保守策略          | 全部时序安全 ✅         |

**关键结论**：

1. **学生 C 获胜**：LZ4 满分（100分）+ 全部时序安全
2. **学生 B**：SHA-256 虽执行时间最优（100分基础），但时序违例扣10分，得90分
3. **时序违例扣分机制**有效平衡了激进策略与设计可靠性
4. **Slack 计算**：`Slack = Target × 0.9 - Estimated`（Clock Uncertainty = 10%）

**重要提示**：

- ⚠️ 每道题时序违例扣 **10 分**
- ✅ 建议优先保证时序安全，再追求极致性能
- 📊 Clock Uncertainty 固定为 Target 的 10%，**不可修改**

**结论**：

- 学生 C 通过在 LZ4 和 Cholesky 上的满分表现获得第一
- 学生 B 虽然在 SHA-256 上采用激进策略获得满分，但其他题目得分较低
- 学生 A 采用保守策略，时序安全但竞争力不足
- **时序违例不影响评分**，但可能影响设计的实际可用性

---

## 6. 提交要求

### 6.1 提交材料

学生需提交完整的 hlstrack2025 仓库，包含：

1. **修改后的头文件**（每道题目对应的 `*.hpp` 文件）
2. **reports 目录**：每道题目的测试目录下需包含
   - C 仿真日志
   - Co-simulation 日志
   - 综合报告
3. **prompts 目录**：大模型使用记录（`llm_usage.md`）

### 6.2 提交检查清单

- [ ] 所有题目均通过 C Simulation
- [ ] 所有题目均通过 Co-simulation
- [ ] 已提取并保存 cosim.log
- [ ] 已填写 LLM 使用记录（如使用）
- [ ] 仓库结构完整（未删除其他文件）

---

## 7. 常见问题

### Q0: Baseline 基准数据是多少？

**A**: 以下是三道题目的官方 Baseline 参考数据：（Windows Vitis 2024.2 测得）

| 题目            | 算法         | Target Clock (ns) | Estimated Clock (ns) | Clock Uncertainty (ns) | Slack (ns) | Cosim Latency (cycles) | 执行时间 (ns) | 时序状态 |
| --------------- | ------------ | ----------------- | -------------------- | ---------------------- | ---------- | ---------------------- | ------------- | -------- |
| **题目1** | SHA-256      | 15                | 13.846               | 10%                    | Pass       | 809                    | 11201.4       | Pass     |
| **题目2** | LZ4 Compress | 15                | 13.220               | 10%                    | Pass       | 3390                   | 44815.8       | Pass     |
| **题目3** | Cholesky     | 7                 | 6.276                | 10%                    | Pass       | 4919                   | 30871.6       | Pass     |

**Slack 计算方式**：

```
Slack = (Target × 0.9) - Estimated
示例：SHA-256 的 Slack = 10.0 × 0.9 - 9.5 = 9.0 - 9.5 = -0.5 ns
```

**重要提示**：

- ✅ Baseline 的执行时间是你需要超越的目标
- ⚠️ Baseline 存在时序违例，因此其得分也会被扣 10 分
- 🎯 优化目标：降低执行时间 **并且** 保持时序安全（Slack > 0）
- 📊 以上数据为示例，实际 Baseline 以竞赛公布为准

**优化建议**：

1. **优先策略**：先实现时序安全的设计（Slack > 0），避免扣分
2. **性能策略**：在时序安全的基础上，降低执行时间
3. **激进策略**：可以尝试时序违例但执行时间更短的方案，权衡扣分与性能

---

### Q1: 如果只完成部分题目怎么办？

**A**: 可以提交，但：

- 未完成的题目得 0 分
- 无法获得完整性加分（或仅获得部分加分）
- 建议至少完成 2 道题目以获得基础加分

### Q2: 可以修改时钟频率吗？

**A**: **可以**。本次竞赛允许修改时钟频率，但需注意时序违例扣分规则：

- ✅ **允许修改**：可以修改 Tcl 脚本或 Makefile 中的时钟配置
- 📊 **评分方式**：按照 `Estimated Clock Period × Cosim Latency` 计算执行时间
- ⚠️ **时序违例扣分**：若 Slack ≤ 0，该题扣除 **10 分**
- 📐 **Slack 计算公式**（Vitis HLS 内部）：
  ```
  Slack = (Target × 0.9) - Estimated
  Clock Uncertainty = Target × 10%（固定不可修改）
  ```

**优化策略对比**：

| 策略               | 时钟周期 | Latency要求  | 时序风险    | 扣分风险   |
| ------------------ | -------- | ------------ | ----------- | ---------- |
| **激进高频** | 3-5 ns   | 可适当放松   | ⚠️⚠️ 高 | 可能扣10分 |
| **平衡策略** | 7-9 ns   | 需优化       | ⚠️ 中等   | 时序可控   |
| **保守低频** | 10-15 ns | 必须极致优化 | ✅ 低       | 无扣分风险 |

**示例计算**：

```
方案A（保守）：
  Target = 10 ns, Estimated = 8.5 ns, Latency = 500
  Slack = 10×0.9 - 8.5 = +0.5 ns ✅ 无扣分
  执行时间 = 4,250 ns

方案B（激进）：
  Target = 5 ns, Estimated = 4.8 ns, Latency = 700
  Slack = 5×0.9 - 4.8 = -0.3 ns ⚠️ 扣10分
  执行时间 = 3,360 ns（最优，但扣分）
```

**建议**：在报告中说明时序状态和扣分风险权衡。

- 方案 C：3 ns × 1,200 cycles = 3,600 ns（时序严重违例 ⚠️⚠️，但评分最高）

**建议**：在报告中说明是否存在时序违例及原因。

### Q3: Co-simulation 很慢怎么办？

**A**: Co-simulation 确实耗时较长，建议：

- 先用 C Simulation 快速验证功能
- 优化完成后再运行 Co-simulation
- 仅提交一次 Co-simulation 结果

### Q4: 资源超限怎么办？

**A**: 若优化后的设计超过 xc7z020 资源限制：

- 该题目得 0 分（视为未通过验证）
- 需要权衡 Latency 与资源使用
- 建议使用 `csynth.rpt` 提前检查资源使用情况

### Q5: 如何确认自己的评分指标？

**A**: 需要提取两个关键数据：

**1. Estimated Clock Period（估计时钟周期）**

在 C Synthesis 报告（`*_csynth.rpt`）中查找：

```
================================================================
== Timing Summary
================================================================
+ Timing: 
    * Summary: 
    +---------+---------+----------+------------+
    |  Clock  |  Target | Estimated| Uncertainty|
    +---------+---------+----------+------------+
    |default  |  10.00  |   8.532  |    1.00    |
    +---------+---------+----------+------------+
```

使用 **Estimated** 列的值（本例：8.532 ns）
**注意**：Uncertainty 列显示的是 Clock Uncertainty，应该是 Target 的 10%（本例：1.0 ns）

**2. Cosim Latency（协同仿真延迟）**

在 Co-simulation 报告（`*_cosim.rpt`）中查找：

```
|         Latency (cycles)         |
|    min   |    max   |    avg    |
|----------|----------|-----------|
|   500    |   650    |   575     |
```

使用 **max** 值（本例：650 cycles）

**3. 计算 Slack（时序裕量）**

根据 Vitis HLS 工具公式：

```
Slack = (Target × 0.9) - Estimated
      = (10.00 × 0.9) - 8.532
      = 9.0 - 8.532
      = +0.468 ns ✅ 时序满足
```

**4. 计算执行时间**

```
Execution Time = 8.532 ns × 650 = 5,545.8 ns
```

**5. 判断是否扣分**

```
若 Slack > 0  → 无扣分
若 Slack ≤ 0 → 扣除 10 分
```

**完整示例**：

```
情况1（时序安全）：
  Target = 10 ns, Estimated = 8.5 ns, Latency = 600
  Slack = 10×0.9 - 8.5 = +0.5 ns ✅
  执行时间 = 5,100 ns
  得分 = (基于执行时间计算) + 0（无扣分）

情况2（时序违例）：
  Target = 8 ns, Estimated = 7.5 ns, Latency = 600  
  Slack = 8×0.9 - 7.5 = -0.3 ns ⚠️
  执行时间 = 4,500 ns
  得分 = (基于执行时间计算) - 10（扣分）
```

**6.判断是否资源超出限制**

在Vivado Place & Route Results 报告（hls/impl/report/report/verilog/export_impl.rpt）中查找：

如果Place & Route Fail Fast的Status均显示OK则资源符合要求，未超出限制。

如果Place & Route Fail Fast的Status有任意模块显示Review，则单题目减去5分。

```
================================================================
== Place & Route Fail Fast
================================================================
+-----------------------------------------------------------+-----------+--------+--------+
| Criteria                                                  | Guideline | Actual | Status |
+-----------------------------------------------------------+-----------+--------+--------+
| LUT                                                       | 70%       | 14.49% | OK     |
| FD                                                        | 50%       | 12.90% | OK     |
| LUTRAM+SRL                                                | 25%       | 9.68%  | OK     |
| MUXF7                                                     | 15%       | 0.48%  | OK     |
| DSP                                                       | 80%       | 0.00%  | OK     |
| RAMB/FIFO                                                 | 80%       | 0.36%  | OK     |
| DSP+RAMB+URAM (Avg)                                       | 70%       | 0.36%  | OK     |
| BUFGCE* + BUFGCTRL                                        | 24        | 0      | OK     |
| DONT_TOUCH (cells/nets)                                   | 0         | 0      | OK     |
| MARK_DEBUG (nets)                                         | 0         | 0      | OK     |
| Control Sets                                              | 998       | 374    | OK     |
| Average Fanout for modules > 100k cells                   | 4         | 2.96   | OK     |
| Max Average Fanout for modules > 100k cells               | 4         | 0      | OK     |
| Non-FD high fanout nets > 10k loads                       | 0         | 0      | OK     |
+-----------------------------------------------------------+-----------+--------+--------+
| TIMING-6 (No common primary clock between related clocks) | 0         | 0      | OK     |
| TIMING-7 (No common node between related clocks)          | 0         | 0      | OK     |
| TIMING-8 (No common period between related clocks)        | 0         | 0      | OK     |
| TIMING-14 (LUT on the clock tree)                         | 0         | 0      | OK     |
| TIMING-35 (No common node in paths with the same clock)   | 0         | 0      | OK     |
+-----------------------------------------------------------+-----------+--------+--------+
| Number of paths above max LUT budgeting (0.575ns)         | 0         | 0      | OK     |
| Number of paths above max Net budgeting (0.403ns)         | 0         | 0      | OK     |
+-----------------------------------------------------------+-----------+--------+--------+
```

---

---

**优化建议**：

- **SHA-256**：重点优化循环展开、数据流水线
- **LZ4 Compress**：关注数据依赖、内存访问模式
- **Cholesky (ARCH0)**：
  - 复数定点运算优化
  - 循环流水线设计（关注对角线计算和非对角线更新）
  - 数组分区减少访存冲突
  - 平方根运算延迟优化
  - 利用矩阵对称性减少计算量

---

## 8. 优化策略建议

### 8.1 频率与延迟权衡

由于评分标准为 `Execution_Time = Clock_Period × Latency`，参赛者需要在以下两个维度之间找到平衡：

| 优化维度                           | 策略                             | 优势                        | 风险                           |
| ---------------------------------- | -------------------------------- | --------------------------- | ------------------------------ |
| **降低时钟周期**（提高频率） | 减小 `create_clock -period` 值 | 相同 Latency 下执行时间更短 | 容易出现时序违例（Slack < 0）  |
| **降低 Latency**             | 循环展开、流水线优化             | 减少总周期数                | 可能增加关键路径延迟，影响频率 |
| **平衡优化**                 | 同时优化频率和延迟               | 最优执行时间                | 需要深入理解时序和架构         |

### 8.2 算法特定建议

**SHA-256**：

- 重点优化循环展开、数据流水线
- 重点优化循环 II（Initiation Interval）
- 尝试增加时钟频率（减小周期），SHA-256 逻辑相对简单，时序压力较小

**LZ4 Compress**：

- 关注数据依赖、内存访问模式、状态机优化
- 平衡策略：适度降低频率以满足复杂控制逻辑的时序要求
- 重点优化循环 II（Initiation Interval）

**Cholesky (ARCH0)**：

- 复数定点运算优化
- 循环流水线设计（关注对角线计算和非对角线更新）
- 数组分区减少访存冲突
- 平方根运算延迟优化
- 利用矩阵对称性减少计算量

## 9. 联系与支持

- **技术问题**：请在QQ竞赛群 1022632722 提问
- **提交问题**：检查 SUBMISSION_GUIDE 文档

---

**祝各位同学取得好成绩！**

---

*更新日期：2025-10-21*
*修订内容：允许修改时钟频率，评分基于执行时间（Clock Period × Latency）*
